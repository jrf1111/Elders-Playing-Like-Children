---
title: "EPLC Mortality Model"
author: "Jacob W. Roden-Foreman"
date: "`r Sys.time()`"
output:
  html_document:
    pandoc_args: "--dpi=150"
    fig_height: 3
    fig_width: 5
    code_folding: show
    df_print: kable
    toc: true
    toc_depth: 3
    toc_float: true
editor_options: 
  chunk_output_type: console
---

# Setup and import  

```{r setup}
knitr::opts_chunk$set(echo = TRUE,
											results = "asis")

library(tidyverse)
library(tidylog)
library(data.table)
library(fst)
suppressMessages(library(bit64))
library(weights)
library(glmnet)
library(mgcv)
library(gammit)



```



\
\
\
\



# Preprocessing
```{r preprocessing}



mdata = read_fst("Data/final/final combined dataset.fst",
								 columns = c('hosp_ed', 'year_whole',
								 						'discwt', 'neds_stratum', 
								 						'age',
								 						'age_group',
								 						'female', 'zipinc_qrtl',
								 						'pay1_recode', 
								 						'pDeath', 'elixhauser',
								 						'mortality', 
								 						'high_risk', "hr_group", 
								 						'hosp_trauma_level',
								 						'injury_brain', 'injury_skull_fx',
								 						'injury_cspine', 'injury_rib_fx',
								 						'injury_cardio_pulm', 'injury_tspine',
								 						'injury_lspine', 'injury_solid_abd',
								 						'injury_hollow_abd', 'injury_ue_fx',
								 						'injury_pelvic_fx', 'injury_le_fx'
								 )
)

mdata = mdata %>% filter(high_risk == "High-risk")

mdata$hosp_ed = as.factor(mdata$hosp_ed)




#very small number of deaths in some groups
mdata %>% group_by(hr_group) %>% 
    summarise(n = sum(discwt),
              dead_n = sum(discwt[mortality==1]),
              mort_rate = scales::percent( dead_n / n, accuracy = 0.01)
    ) %>% 
    arrange(desc(dead_n))



#only use the four groups with >50 deaths
mdata = mdata %>% 
	filter(hr_group %in% c("Motorcycle Related", 
												 "Pedal Cycle Related", 
												 "Off-Road Vehicle", 
												 "Watercraft Related"))

mdata$hr_group = forcats::fct_drop(mdata$hr_group)





#separate everything out into (sparse) matrices to reduce memory pressure
Y = mdata$mortality

W = mdata$discwt


mdata = mdata %>% mutate_at(vars(starts_with("injury_")), as.integer)

mdata$zipinc_qrtl = factor(mdata$zipinc_qrtl, ordered = F)

library(Matrix)

temp = poly(mdata$age, 3)
mdata$age_L = temp[, 1]
mdata$age_Q = temp[, 2]
mdata$age_C = temp[, 3]
rm(temp)


mdata$pDeath_logit = arm::logit(mdata$pDeath)



X = sparse.model.matrix( ~ 
												 	#demographics
												 	age_L + age_Q + age_C + age_group + female + zipinc_qrtl + pay1_recode + 
												 	
												 	#case mix vars
												 	pDeath_logit + elixhauser +
												 	
												 	#high risk groups
												 	hr_group + 
												 	
												 	#injuries
												 	injury_brain + injury_skull_fx + injury_cspine + 
												 	injury_rib_fx + injury_cardio_pulm + injury_tspine + 
												 	injury_lspine + injury_solid_abd + injury_hollow_abd + 
												 	injury_ue_fx + injury_pelvic_fx + injury_le_fx + 
												 	
												 	#level 2 fixed effects
												 	hosp_trauma_level + year_whole
												 ,
												 mdata
)
X = X[, -1] #remove the intercept










#define training (80%) and testing (20%) samples
set.seed(1111)
train = rbinom(n = nrow(mdata), size = 1, prob = 0.8) %>% as.logical()







```




# Variable Selection  

```{r vs}

#about 8 minutes
invisible(gc())
start = Sys.time()
start
cv_fit = cv.glmnet(y = Y[train], 
									 x = X[train, ],
									 weights = W[train],

									 #trace.it = 1, #print progress
									 
									 nfolds = 50,
									 family = "binomial", 
									 type.measure = "deviance", #use deviance as loss function
									 
									 #instead of default "Newton", which uses the exact hessian:
									 type.logistic = "modified.Newton", 
									 alpha = 1  #LASSO
									 
)
stop = Sys.time()
stop - start
beepr::beep()


plot(cv_fit)


# lambda.min is the value of lambda that gives minimum mean cross-validated error. 
log(cv_fit$lambda.min)
coef(cv_fit, s = "lambda.min") %>% as.matrix()
# has too many predictors



# lambda.1se is the most regularized model with loss that is within one standard error of model with the least loss.
log(cv_fit$lambda.1se)
coef(cv_fit, s = "lambda.1se") %>% as.matrix()
#takes everything out except age, age^2, age_group85+, 
# female, pay1_recodeSelf-pay, pDeath_logit, 
# injury_skull_fx, injury_cspine, 
# injury_cardio_pulm, injury_hollow_abd,
# injury_ue_fx, injury_pelvic_fx








#final choice:
coef(cv_fit, s = "lambda.1se") %>% as.matrix()

coefs = coef(cv_fit, s = "lambda.1se")
coefs = data.frame( var = rownames(coefs),  b = matrix(coefs)  )
coefs = coefs[coefs$b != 0, ]
coefs

rm(cv_fit, X, Y, W, start, stop)


```


\
\



# Testing Model

https://m-clark.github.io/posts/2019-10-20-big-mixed-models/#additive-models-as-mixed-models


```{r testing model}


test = mdata %>% filter(train != TRUE)
format(nrow(test), big.mark = ",")
format(round(sum(test$discwt)), big.mark = ",")



test$hosp_trauma_level = factor(test$hosp_trauma_level,
																ordered = FALSE)

test$year_whole = factor(test$year_whole)

test = test %>% mutate_if(is.logical, as.integer)





#~8 mins 
start = Sys.time()
start
mort_mod = bam(mortality ~ 
							 	#level 1 fixed effects:
							 	poly(age, 3, raw = T) + female + 
							 	
							 	pay1_recode + 
							 	
							 	injury_skull_fx + injury_cspine + 
							 	injury_cardio_pulm + injury_hollow_abd + 
							 	injury_ue_fx + injury_pelvic_fx + 
							 	
							 	pDeath_logit + elixhauser +
							 	
							 	#level 2 fixed effects:
							 	hosp_trauma_level + year_whole + 
							 	
							 	#random effects via smoothers:
							 	s(hr_group, bs = "re") +
							 	s(hosp_ed, bs = "re") + 
							 	s(neds_stratum, bs = "re"),
							 
							 family = binomial("logit"),
							 weights = test$discwt,
							 data = test,
							 
							 discrete = TRUE,
							 control = list(nthreads = 3, trace = TRUE)
							 
)
end = Sys.time()
beepr::beep()

end - start

saveRDS(mort_mod, "Results/mort_mod.RDS")

options(show.signif.stars = F)

summary(mort_mod, re.test = F)


fixed = extract_fixed(mort_mod, ci_level = 1-0.005, digits = 5) 
fixed$OR = sprintf("%.2f", exp(fixed$value))
fixed$CI = paste0( sprintf("%.2f", exp(fixed$lower_0.05)), ", ", 
									 sprintf("%.2f", exp(fixed$upper_99.95)))
fixed$pval = if_else(fixed$p < 0.0001, "< 0.0001", sprintf("%.3f", fixed$p))
TCCD::my_print(fixed)





ranef = extract_ranef(mort_mod, re = "hr_group", ci_level = 1-0.005, digits = 5) 
ranef$OR = sprintf("%.2f", exp(ranef$value))
ranef$CI = paste0( sprintf("%.2f", exp(ranef$lower_0.25)), ", ", 
									 sprintf("%.2f", exp(ranef$upper_99.75)))
ranef$pval = pnorm(abs(ranef$value/ranef$se) , lower.tail = F)*2
ranef$pval = if_else(ranef$pval < 0.0001, "< 0.0001", sprintf("%.3f", ranef$pval))
TCCD::my_print(ranef)
















#~8 mins 
start = Sys.time()
start
mort_mod2 = bam(mortality ~ 
									#level 1 fixed effects:
									poly(age, 3, raw = T) + female + 
									
									pay1_recode + 
									
									injury_skull_fx + injury_cspine + 
									injury_cardio_pulm + injury_hollow_abd + 
									injury_ue_fx + injury_pelvic_fx + 
									
									pDeath_logit + elixhauser +
									
									hr_group +
									
									#level 2 fixed effects:
									hosp_trauma_level + year_whole + 
									
									#random effects via smoothers:
									s(hosp_ed, bs = "re") + 
									s(neds_stratum, bs = "re"),
								
								family = binomial("logit"),
								weights = test$discwt,
								data = test,
								
								discrete = TRUE,
								control = list(nthreads = 3, trace = TRUE)
								
)
end = Sys.time()
beepr::beep()

end - start


summary(mort_mod2, re.test = F)




#need pairwise comparisons.  
# This doesn't work: multcomp::glht(mort_mod2, linfct = multcomp::mcp(hr_group = "Tukey"))







```


\
\
\
\





```{r} 
pander::pander(sessionInfo())
```
